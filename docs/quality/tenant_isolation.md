# Tenant Isolation Test Suite

**Status:** Active
**Owner:** Quality Engineering
**Last Updated:** 2026-01-03
**Related ADRs:** ADR-001 Tenancy Strategy
**Architecture Reference:** Section 3.0 Rulebook - Tenant Safety, Section 5.0 Multi-Tenancy & Data Isolation

---

## Overview

The tenant isolation test suite (`TenantIsolationIT.java`) provides comprehensive validation that multi-tenant data boundaries are enforced at three critical layers:

1. **Repository Layer:** Panache filters ensure all database queries are scoped by `tenant_id`
2. **Service Layer:** Business logic validates tenant ownership before mutating operations
3. **HTTP Layer:** Request routing respects subdomain-based tenant resolution

This suite is **mandatory** in the CI pipeline and must pass before any PR can merge. Tests are designed to fail explicitly when tenant isolation mechanisms are disabled or bypassed. A dedicated Quarkus test resource (`PostgresTenantTestResource`) provisions PostgreSQL through Testcontainers so real row-level policies can be toggled during the run.

---

## Test Dataset

The suite uses two deterministic tenants to validate isolation:

### Tenant A
- **Subdomain:** `tenant-a-iso`
- **Products:** SKU prefix `A-` (e.g., `A-WIDGET-001`)
- **Carts:** Session ID `aaaaaaaa-5555-6666-7777-888888888888`

### Tenant B
- **Subdomain:** `tenant-b-iso`
- **Products:** SKU prefix `B-` (e.g., `B-WIDGET-001`)
- **Carts:** Session ID `bbbbbbbb-5555-6666-7777-888888888888`

> **Note:** Tenant IDs are generated by PostgreSQL at runtime. Subdomains, SKU prefixes, and session IDs are deterministic so assertions can rely on them.

All test data is created in `@BeforeEach` and cleaned up in `@AfterEach` to ensure test isolation on a dedicated PostgreSQL container.

---

## Running the Test Suite

The suite relies on Testcontainers (Docker) to start PostgreSQL so RLS policies can be exercised. Ensure Docker Desktop (or another container runtime) is running before executing the tests.

### Local Execution

Run the full integration test suite:

```bash
./mvnw test -Dtest=TenantIsolationIT
```

Run the entire CI harness (includes lint + this suite):

```bash
node tools/test.cjs
```

Run a specific test case:

```bash
./mvnw test -Dtest=TenantIsolationIT#catalogService_shouldNotFindProductFromDifferentTenant
```

Run with verbose logging to observe tenant context operations:

```bash
./mvnw test -Dtest=TenantIsolationIT -Dquarkus.log.category.\"villagecompute.storefront\".level=DEBUG
```

### CI Pipeline Integration

The test suite is included in the standard CI workflow:

```bash
# Standard CI test execution (includes TenantIsolationIT)
./mvnw clean test

# Coverage report generation (requires 80% coverage per SonarCloud gate)
./mvnw test jacoco:report
```

**CI Failure Indicators:**
- Any test failure in `TenantIsolationIT` blocks PR merge
- Failed tests indicate critical security vulnerability (cross-tenant data leakage)
- DO NOT bypass failures - investigate and fix the root cause immediately

---

## Test Coverage

### Catalog Service Tests

| Test Case | Validates | Expected Behavior |
|-----------|-----------|-------------------|
| `catalogService_shouldNotFindProductFromDifferentTenant` | Catalog read isolation | Fetching by ID returns empty outside current tenant |
| `catalogService_shouldOnlyReturnCurrentTenantProducts` | List filtering | `listActiveProducts` returns SKUs owned by the current tenant only |
| `catalogService_shouldBlockUpdateForDifferentTenantProduct` | Write protection | Updating another tenant’s product triggers `IllegalArgumentException` |
| `catalogService_shouldBlockDeleteForDifferentTenantProduct` | Delete protection | Deleting another tenant’s product triggers `IllegalArgumentException` |
| `catalogService_shouldNotFindProductBySkuFromDifferentTenant` | SKU lookup isolation | `getProductBySku` is scoped per tenant |
| `productRepository_shouldFilterCustomQueriesByTenantContext` | Panache filters | Repository helpers only emit rows for `TenantContext` |
| `repositoryQueries_shouldThrowWhenNoTenantContext` | Guard rails | Repository calls without context throw `IllegalStateException` |

### Cart Service & Repository Tests

| Test Case | Validates | Expected Behavior |
|-----------|-----------|-------------------|
| `cartRepository_shouldFilterCustomQueriesByTenantContext` | Repository filters | `findByCurrentTenant` never leaks foreign carts |
| `cartService_shouldOnlyReturnCurrentTenantCarts` | Service list isolation | Each tenant sees exactly one cart after seeding |
| `cartService_shouldNotFindCartBySessionFromDifferentTenant` | Session-level guard | Session lookups are tenant-scoped |

### HTTP Layer Tests

| Test Case | Validates | Expected Behavior |
|-----------|-----------|-------------------|
| `cartApi_shouldNotAccessCartFromDifferentTenant` | Cross-tenant requests | Tenant B receives 404 when targeting Tenant A carts |
| `cartApi_shouldIsolateCartItemsByTenant` | Payload segregation | Cart totals and item IDs remain isolated per tenant |
| `cartApi_shouldBlockAddingVariantFromDifferentTenant` | Variant enforcement | Adding another tenant’s variant returns 404 |
| `cartApi_shouldBlockCrossSessionAccessWithinSameTenant` | Session boundaries | Wrong session ID within the same tenant cannot mutate carts |

### PostgreSQL RLS Test

| Test Case | Validates | Expected Behavior |
|-----------|-----------|-------------------|
| `rlsPolicy_shouldBlockRawQueryAccessToDifferentTenantData` | Database-level guard | With RLS enabled, raw JPQL queries cannot retrieve foreign tenant rows; disabling RLS inside the test demonstrates the leak that CI protects against |

> **Observability hook:** enable `quarkus.log.category."org.hibernate.SQL".level=DEBUG` while running the suite to capture structured SQL + tenant metadata that can be fed into the Section 6 dashboards for RLS policy hit counts.

---

## Understanding Test Failures

### Common Failure Scenarios

#### Scenario 1: TenantContext Not Set
**Symptom:**
```
java.lang.IllegalStateException: No tenant context available - TenantResolutionFilter not executed
```

**Root Cause:** Service or repository method called without populating `TenantContext`

**Resolution:**
- In HTTP requests: Ensure `TenantResolutionFilter` is executing (check filter registration)
- In background jobs: Explicitly call `TenantContext.setCurrentTenant()` before invoking services
- In tests: Call `TenantContext.setCurrentTenant()` in `@BeforeEach` or test method

#### Scenario 2: Cross-Tenant Data Leakage
**Symptom:**
```
org.opentest4j.AssertionFailedError: expected: <false> but was: <true>
```

**Root Cause:** Repository query returning data from different tenant

**Resolution:**
1. Verify repository method includes `tenant.id = :tenantId` filter
2. Check service layer validates `product.tenant.id.equals(TenantContext.getCurrentTenantId())`
3. Inspect entity `@PrePersist` hooks to ensure `tenant` field populated
4. Review recent changes to repository queries or Panache filters

#### Scenario 3: HTTP Endpoint Returns Wrong Tenant Data
**Symptom:**
```
Expected status code <404> but was <200>
```

**Root Cause:** Tenant resolution from `Host` header not working

**Resolution:**
1. Verify `TenantResolutionFilter` is registered and executing before resource methods
2. Check subdomain parsing logic in filter
3. Inspect `Host` header value in logs to confirm correct format
4. Review custom domain resolution if applicable

#### Scenario 4: RLS Enforcement Missing
**Symptom:**
```
org.opentest4j.AssertionFailedError: PostgreSQL RLS must block Tenant A from selecting Tenant B product via raw query
```

**Root Cause:** RLS policies were disabled (manually or by regression) and the raw JPQL query leaked cross-tenant data.

**Resolution:**
1. Inspect `TenantIsolationIT.enableRowLevelSecurityPolicies()` to confirm policies are being created per table.
2. Ensure the database connection set `app.current_tenant_id` before executing queries (see `setDatabaseTenant` helper).
3. Re-run only the RLS test: `./mvnw test -Dtest=TenantIsolationIT#rlsPolicy_shouldBlockRawQueryAccessToDifferentTenantData`.
4. Once RLS is confirmed working, keep it enabled—CI will fail immediately if someone disables it again.

---

## How PostgreSQL RLS Enforcement Works

### Current State (Panache + Test-Installed RLS)

Production code still guards tenant data through Panache filters and `TenantContext`. The test harness temporarily installs PostgreSQL RLS policies (via `enableRowLevelSecurityPolicies`) inside the Testcontainers database so we can validate how the platform should behave once migrations are updated.

1. Panache filters keep repositories honest for the majority of tests.
2. `rlsPolicy_shouldBlockRawQueryAccessToDifferentTenantData` enables RLS, sets `app.current_tenant_id`, and proves raw queries cannot bypass tenant isolation.
3. The same test disables RLS at the end to document the blast radius if someone turns policies off.

### Future State (Schema-Managed RLS)

When `V20260102__baseline_schema.sql` grows real policies, the helper methods in `TenantIsolationIT` can be removed and the migrations will keep production databases aligned with the behavior we already test.

**Reference Policy Snippet:**
```sql
-- Enable RLS on tenant-scoped tables
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE product_variants ENABLE ROW LEVEL SECURITY;
ALTER TABLE carts ENABLE ROW LEVEL SECURITY;
ALTER TABLE cart_items ENABLE ROW LEVEL SECURITY;

-- Create policies (example for products table)
CREATE POLICY tenant_isolation_policy ON products
  USING (
    current_setting('app.current_tenant_id', true) IS NOT NULL
    AND tenant_id = current_setting('app.current_tenant_id', true)::uuid
  )
  WITH CHECK (
    current_setting('app.current_tenant_id', true) IS NOT NULL
    AND tenant_id = current_setting('app.current_tenant_id', true)::uuid
  );

-- Application sets tenant context via session variable, just like the test helper does
SELECT set_config('app.current_tenant_id', 'aaaaaaaa-1111-2222-3333-444444444444', false);
```

**Test Impact:**
- `rlsPolicy_shouldBlockRawQueryAccessToDifferentTenantData` validates database-level enforcement today.
- If someone disables RLS (`ALTER TABLE ... DISABLE ROW LEVEL SECURITY`), that test fails immediately when the first raw query returns data.

---

## Extending the Test Suite

### Adding Tests for New Entities

When adding tenant-scoped entities (e.g., `Order`, `Customer`), add corresponding isolation tests:

1. **Service Layer Test:**
```java
@Test
@Transactional
void orderService_shouldNotFindOrderFromDifferentTenant() {
    TenantContext.setCurrentTenant(tenantAInfo);
    // Create order in Tenant A
    Order orderA = orderService.createOrder(...);

    TenantContext.clear();
    TenantContext.setCurrentTenant(tenantBInfo);

    // Should return empty
    Optional<Order> result = orderService.getOrder(orderA.id);
    assertFalse(result.isPresent());
}
```

2. **HTTP Layer Test:**
```java
@Test
void orderApi_shouldNotReturnOrderFromDifferentTenantDomain() {
    // Create order in Tenant A
    String orderId = requestForTenant(TENANT_A_SUBDOMAIN, SESSION_A)
        .body(orderRequest).post("/api/v1/orders")
        .then().statusCode(201).extract().path("id");

    // Try to fetch via Tenant B subdomain
    requestForTenant(TENANT_B_SUBDOMAIN, SESSION_B)
        .get("/api/v1/orders/" + orderId)
        .then().statusCode(404);
}
```

3. **Repository Layer Test:**
```java
@Test
@Transactional
void orderRepository_shouldFilterByTenantContext() {
    TenantContext.setCurrentTenant(tenantAInfo);
    Order order = createTestOrder(tenantA);

    TenantContext.clear();
    TenantContext.setCurrentTenant(tenantBInfo);

    Optional<Order> result = orderRepository.findByIdOptional(order.id);
    assertFalse(result.isPresent());
}
```

### Testing Multi-Tenant Background Jobs

For scheduled jobs iterating across tenants:

```java
@Test
void backgroundJob_shouldProcessEachTenantIsolated() {
    // Job must set TenantContext per iteration
    List<UUID> tenantIds = List.of(TENANT_A_ID, TENANT_B_ID);

    for (UUID tenantId : tenantIds) {
        Tenant tenant = Tenant.findById(tenantId);
        TenantContext.setCurrentTenant(new TenantInfo(tenant.id, ...));

        try {
            // Job logic here - should only access current tenant data
            processExpiredCarts();
        } finally {
            TenantContext.clear(); // CRITICAL: Prevent context leakage
        }
    }
}
```

---

## Troubleshooting Checklist

When investigating tenant isolation failures:

- [ ] Verify `TenantContext.setCurrentTenant()` called before service invocation
- [ ] Confirm `TenantContext.clear()` in `@AfterEach` to prevent test crosstalk
- [ ] Check repository queries include `tenant.id = :tenantId` parameter
- [ ] Inspect entity `@PrePersist` hooks to ensure `tenant` field set
- [ ] Review `TenantResolutionFilter` execution order in filter chain
- [ ] Validate `Host` header format in HTTP tests (`subdomain.villagecompute.com`)
- [ ] Confirm session ID uniqueness across test tenants
- [ ] Examine logs for `TenantContext` operations (`DEBUG` level)
- [ ] Run single test in isolation to rule out data contamination
- [ ] Verify database schema matches migration expectations

---

## CI Integration

### GitHub Actions Workflow

The test suite runs in the standard CI pipeline:

```yaml
- name: Run Tests
  run: ./mvnw test

- name: Generate Coverage Report
  run: ./mvnw jacoco:report

- name: SonarCloud Scan
  env:
    SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
  run: |
    ./mvnw sonar:sonar \
      -Dsonar.organization=villagecompute \
      -Dsonar.projectKey=village-storefront \
      -Dsonar.qualitygate.wait=true
```

**Quality Gate Requirements:**
- **Coverage:** ≥80% line and branch coverage
- **Bugs:** 0 (APPI profile)
- **Vulnerabilities:** 0
- **Test Success:** All tests pass (including `TenantIsolationIT`)

### Manual RLS Validation

To manually verify RLS enforcement once policies are enabled:

1. **Run tests with RLS enabled:**
```bash
./mvnw test -Dtest=TenantIsolationIT
# All tests should pass, no "[TENANT ISOLATION GAP]" warnings
```

2. **Disable RLS and verify test failure:**
```sql
-- In database
ALTER TABLE products DISABLE ROW LEVEL SECURITY;
ALTER TABLE product_variants DISABLE ROW LEVEL SECURITY;
ALTER TABLE carts DISABLE ROW LEVEL SECURITY;
ALTER TABLE cart_items DISABLE ROW LEVEL SECURITY;
```

```bash
./mvnw test -Dtest=TenantIsolationIT#rlsPolicy_shouldBlockRawQueryAccessToDifferentTenantData
# Should FAIL - raw query returns cross-tenant data
```

3. **Re-enable RLS and confirm fix:**
```sql
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE product_variants ENABLE ROW LEVEL SECURITY;
ALTER TABLE carts ENABLE ROW LEVEL SECURITY;
ALTER TABLE cart_items ENABLE ROW LEVEL SECURITY;
```

```bash
./mvnw test -Dtest=TenantIsolationIT
# Should PASS
```

---

## References

- **Implementation:** `src/test/java/villagecompute/storefront/TenantIsolationIT.java`
- **Architecture:** `docs/architecture/02_System_Structure_and_Data.md` Section 5
- **ADR:** `docs/adr/ADR-001-tenancy.md`
- **Migration:** `src/main/resources/db/migrations/V20260102__baseline_schema.sql` (RLS TODOs)
- **Tenant Context:** `src/main/java/villagecompute/storefront/tenant/TenantContext.java`
- **Test Harness:** `src/test/java/villagecompute/storefront/testsupport/PostgresTenantTestResource.java`
- **Related Tests:**
  - `src/test/java/villagecompute/storefront/services/CatalogServiceTest.java`
  - `src/test/java/villagecompute/storefront/api/rest/CartResourceTest.java`

---

## Change Log

| Date       | Change | Author |
|------------|--------|--------|
| 2026-01-03 | Initial tenant isolation test suite and documentation | CodeImplementer Agent (Task I2.T6) |
| 2026-01-03 | Added Postgres Testcontainers harness, RLS enforcement details, and refreshed coverage notes | CodeValidator Agent |

---

**For questions or issues with the test suite, contact the Platform Security team or file an issue in the repository.**
