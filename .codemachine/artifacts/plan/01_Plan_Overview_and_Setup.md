<!-- anchor: project-plan-root -->
# Project Plan: Village Storefront

**Version:** 1.0
**Date:** 2026-01-02
**Generated By:** Codex (GPT-5)

<!-- anchor: project-overview -->
## 1. Project Overview

*   **Goal:** Deliver a Quarkus-based SaaS commerce platform that fuses multi-tenant storefronts, consignment parity, and platform governance into a scalable, operable foundation for VillageCompute merchants.
*   **High-Level Requirements Summary:**
    - Multi-tenant tenancy resolution via subdomains/custom domains plus PostgreSQL RLS; CORS, feature flags, and audit-ready impersonation built into every slice.
    - Storefront rendered with Qute/Tailwind/PrimeUI, admin SPA powered by Vue 3/PrimeVue, and headless REST APIs for carts, catalog, and orders.
    - Deep commerce set: product variants, inventory, consignment workflows, loyalty, POS offline mode, shipping integrations, digital goods, gift cards, and Stripe Connect payments.
    - Media and background processing pipeline for image/video transforms, report exports, payouts, and archival routines using database-backed DelayedJob queues and FFmpeg.
    - Observability, CI/CD, and deployment stack anchored on Quarkus native builds, Kubernetes (k3s), GitHub Actions, OpenTelemetry, Prometheus, and structured logging.
    - Non-functional guardrails: JWT auth, bcrypt, PCI-safe payments, <200ms API targets, <2s storefront loads, archival retention, audit trails, and multilingual readiness (EN/ES first).
*   **Key Assumptions:**
    - Architecture follows VillageCompute Java standards (Java 21, Quarkus, Maven, Spotless, JaCoCo, MyBatis migrations, DelayedJob) without deviation unless recorded via ADRs.
    - Stripe remains the only live payment rail for MVP, but PaymentProvider abstraction must allow PayPal/CashApp/Square plug-ins without schema changes.
    - Tenants operate on shared PostgreSQL 17 cluster with tenant_id discriminator columns; no per-tenant databases or Redis caches are available.
    - Kubernetes clusters already provisioned with cert-manager, ingress, Prometheus/Jaeger, and Cloudflare R2 connectivity per platform ops baseline.
    - Internationalization limited to English/Spanish content shells; merchant-authored copy handles localization of rich content manually.
    - Platform security/legal teams drive audit requirements (impersonation logging, retention, privacy exports) that cannot be deferred to later phases.

<!-- anchor: core-architecture -->
## 2. Core Architecture

*   **Architectural Style:** Layered modular monolith in Quarkus where bounded-context modules (tenant access, identity, catalog, consignment, checkout, payments, loyalty, POS, media, reporting, platform ops) communicate via CDI interfaces and domain events persisted in PostgreSQL; design keeps seams ready for gradual service extraction.
*   **Technology Stack:**
    *   Frontend: Qute templates + Tailwind CSS + PrimeUI widgets for storefront routes; Vue 3 + Vite + TypeScript + PrimeVue for `/admin/*` via Quinoa; POS PWA uses same Vue stack with Workbox offline cache.
    *   Backend: Java 21 + Quarkus extensions (RESTEasy Reactive, Qute, Panache, Scheduler, Mailer, AWS S3, Kubernetes); GraalVM native compilation and Maven build with Spotless/JaCoCo gates.
    *   Database: PostgreSQL 17 (shared cluster) with tenant_id columns, RLS policies, partitioned audit/session tables, pgcrypto for sensitive fields; MyBatis migrations manage schema, RLS, and seed data.
    *   Messaging/Queues: Database-backed DelayedJob tables (CRITICAL→BULK priorities) executed by Quarkus workers; CDI events for in-process notifications; no Redis/broker allowed.
    *   Deployment: GitHub Actions builds GraalVM native container images, Quarkus Kubernetes extension emits manifests, Kustomize overlays per env, deployed to k3s with cert-manager and Cloudflare CDN.
    *   Other Key Libraries/Tools: TenantContext request filter, FeatureToggle service with Caffeine cache, JWT + refresh tokens, Stripe SDK/Stripe Terminal, AWS SDK S3 (Cloudflare R2), Java ImageIO + Thumbnailator, FFmpeg CLI, OpenTelemetry, Prometheus, Caffeine caching, MapStruct, Spotless, JaCoCo, SonarCloud.
*   **Key Components/Services:** (detailed Component Diagram in `docs/diagrams/component_overview.puml` via `I1.T3`)
    - Tenant Access Gateway: Host header + custom-domain resolution, CORS policy injection, TenantContext broadcast.
    - Identity & Session Service: JWT issuance, refresh tokens, MFA hooks, session/audit logging, platform impersonation control.
    - Storefront Rendering Engine: Qute templates orchestrating catalog/cart/checkout data with Tailwind tokens and PrimeUI hydration.
    - Admin SPA Delivery / POS Shell: Vue-based assets served via Quinoa, bootstrap config, offline support, command palette.
    - Catalog & Inventory Module: Products, variants, categories, collections, inventory locations/levels, import/export, search indexing.
    - Consignment Module: Consignor onboarding, commission rules, intake batches, payouts, vendor portal.
    - Checkout & Order Orchestrator: Cart persistence, shipping rates, address validation, Stripe intents, order lifecycle, returns/refunds.
    - Payment Integration Layer: PaymentProvider interfaces, Stripe Connect onboarding, payout reconciliation, webhook idempotency store.
    - Loyalty & Rewards Module: Points ledger, tiers, redemption flows, POS tie-in.
    - POS & Offline Processor: Offline queue encryption, barcode/terminal integrations, reconciliation jobs.
    - Media Pipeline Controller: Upload negotiation, FFmpeg/Thumbnailator jobs, CDN metadata, signed URL service.
    - Reporting & Analytics Projection Service: Domain event consumer building aggregates, exports, and platform dashboards.
    - Platform Admin Console Backend: SaaS governance APIs, impersonation, plan/billing, custom domain automation, support tooling.
*   **Data Model Overview:** (ERD captured in `docs/diagrams/datamodel_erd.puml` via `I1.T4`)
    - Multi-tenant core: `Tenant`, `StoreUser`, `Customer`, `FeatureFlag`, `PlatformCommand` with tenant_id and audit metadata.
    - Commerce entities: `Product`, `Variant`, `Category`, `Collection`, `InventoryLocation`, `InventoryLevel`, `MediaAsset`, `MediaDerivative`.
    - Cart/Order: `Cart`, `CartItem`, `Order`, `OrderItem`, `Shipment`, `ReturnAuthorization`, `OrderTimelineEvent`.
    - Payments: `PaymentIntent`, `Refund`, `GiftCard`, `StoreCreditLedger`, `SubscriptionContract`.
    - Consignment: `Consignor`, `ConsignmentItem`, `PayoutBatch`.
    - Loyalty: `LoyaltyLedgerEntry`, `TierDefinition`.
    - Support/Observability: `SessionLog`, `AuditEvent`, `BackgroundJob`, `WebhookEvent`, `DomainEvent`, `RateLimitBucket`.
*   **API Contract Style:** RESTful JSON APIs defined spec-first via OpenAPI 3.0 (base spec scaffolded in `api/v1/openapi.yaml` under `I1.T2`, expanded per iteration). Contracts embed tenant scoping, auth requirements, feature flags, pagination metadata, Problem Details errors, HATEOAS links, and idempotency headers.
*   **Communication Patterns:** Host-based tenant routing -> TenantContext -> CDI events; synchronous REST for storefront/admin/headless, asynchronous domain events + DelayedJob for heavy work. Payment/shipping integrations use adapter layer with retries/circuit breakers. SSE/WS channels provide admin notifications. Sequence diagrams for checkout, consignment payout, media pipeline documented in `docs/diagrams/sequence_*` outputs under iterations `I2.T5`, `I3.T4`, `I4.T5`.

<!-- anchor: key-artifacts -->
## 2.1. Key Architectural Artifacts Planned

*   Component Diagram (PlantUML) – Visualizes bounded-contexts and interactions for Tenant Access, Identity, Catalog, Consignment, Checkout, Payments, Loyalty, POS, Media, Reporting, Platform Ops. Generated in `docs/diagrams/component_overview.puml` during `I1.T3`; informs all technical agents.
*   Data Model ERD (PlantUML) – Captures major entities, tenant_id patterns, RLS-dependent tables, relationships for catalog, orders, payments, loyalty, consignment. Authored in `docs/diagrams/datamodel_erd.puml` via `I1.T4`.
*   Initial OpenAPI Spec (YAML) – `api/v1/openapi.yaml` seeded in `I1.T2`, iteratively expanded each iteration; drives client generation, contract tests, and headless partner onboarding.
*   Tenant Routing Sequence Diagram (Mermaid) – `docs/diagrams/sequence_tenant_routing.mmd` produced in `I1.T5` to document request filter, TenantContext, feature flag hydration.
*   Checkout & Payment Sequence Diagram (Mermaid) – `docs/diagrams/sequence_checkout_payment.mmd` built in `I2.T5` for saga reasoning.
*   Consignment Payout Flow Diagram (Mermaid) – `docs/diagrams/sequence_consignment_payout.mmd` crafted in `I3.T4` to align payout automation.
*   Media Pipeline Flow Diagram (Mermaid) – `docs/diagrams/sequence_media_pipeline.mmd` created in `I4.T5` for FFmpeg/queue orchestration.
*   Deployment Diagram (PlantUML) – `docs/diagrams/deployment_k8s.puml` assembled in `I5.T3` for k3s topology review.
*   ADR Set (Markdown) – `docs/adr/` entries (ADR-001 tenancy, ADR-002 payments, ADR-003 media, etc.) established across iterations to track trade-offs.

<!-- anchor: directory-structure -->
## 3. Directory Structure

*   **Root Directory:** `village-storefront/`
*   **Structure Definition:**
    ~~~
    village-storefront/
    ├── README.md
    ├── docs/
    │   ├── architecture_overview.md
    │   ├── diagrams/
    │   │   ├── component_overview.puml
    │   │   ├── datamodel_erd.puml
    │   │   ├── sequence_tenant_routing.mmd
    │   │   ├── sequence_checkout_payment.mmd
    │   │   ├── sequence_consignment_payout.mmd
    │   │   ├── sequence_media_pipeline.mmd
    │   │   └── deployment_k8s.puml
    │   ├── adr/
    │   │   ├── ADR-001-tenancy.md
    │   │   ├── ADR-002-payments.md
    │   │   └── ...
    │   └── java-project-standards.adoc
    ├── api/
    │   └── v1/
    │       └── openapi.yaml
    ├── src/
    │   ├── main/java/
    │   │   ├── com/village/tenant/
    │   │   ├── com/village/identity/
    │   │   ├── com/village/catalog/
    │   │   ├── com/village/consignment/
    │   │   ├──── com/village/checkout/
    │   │   ├── com/village/payment/
    │   │   ├── com/village/loyalty/
    │   │   ├── com/village/pos/
    │   │   ├── com/village/media/
    │   │   ├── com/village/reporting/
    │   │   └── com/village/platformops/
    │   ├── main/resources/
    │   │   ├── application.properties
    │   │   ├── db/migrations/
    │   │   ├── qute/templates/
    │   │   └── messages/
    │   └── main/webui/
    │       ├── admin-spa/
    │       ├── pos/
    │       └── shared/
    ├── tests/
    │   ├── backend/
    │   ├── storefront/
    │   └── admin/
    ├── tools/
    │   ├── scripts/
    │   └── pipelines/
    ├── .codemachine/
    │   └── inputs/
    ├── pom.xml
    ├── package.json (for admin SPA tooling)
    ├── Dockerfile
    ├── k8s/
    │   ├── base/
    │   └── overlays/{dev,staging,prod}
    └── .github/workflows/
    ~~~
    Key locations earmark documentation (`docs/`), specs (`api/`), module-oriented Java packages, SPA assets under `src/main/webui`, MyBatis migrations under `src/main/resources/db/migrations`, and ops assets (`k8s/`, `tools/`). ADR folder ensures architectural decisions stay versioned. Tests separated by surface to support focused CI lanes.~~~
